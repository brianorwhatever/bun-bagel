// @bun
var W={method:"GET",data:null,headers:new Headers,response:{data:null,headers:new Headers,status:200}};function P(z){const V=`${z.replace(/[.*+?^${}()|[\]\\]/g,"\\$&").replace(/\\\*/g,"[\\s\\S]*")}\$`;return new RegExp(V)}var v=(z)=>(X)=>{const[J,V]=z,[Y,Z]=X;if(!(J.toString()===Y.toString()||J.match(Y)))return!1;const $=V?.method||"GET",b=Z?.method||"GET";if($.toLowerCase()!==b.toLowerCase())return!1;const w=new Headers(V?.headers);if(![...new Headers(Z?.headers).entries()].every(([B,D])=>{return w.get(B)===D}))return!1;return!0},Q=(z,X,J=W)=>{const{headers:V,data:Y,response:Z}=J,G=z>=200&&z<300,$=Z?.data??Y;return{ok:G,status:z,statusText:z,url:X,headers:Z?.headers??V,text:()=>Promise.resolve($),json:()=>Promise.resolve($),redirected:!1,bodyUsed:!!$}};var x,j=new Map,C=(z,X=W)=>{const J=z instanceof Request?z.url:z,V=J instanceof RegExp?J:new RegExp(P(J.toString())),Y=[...j.entries()].find(v([V.toString(),X]));if(process.env.VERBOSE){if(!Y)console.debug("\x1B[1mRegistered mocked request\x1B[0m");else console.debug("\x1B[1mRequest already mocked\x1B[0m \x1B[2mupdated\x1B[0m");console.debug("\x1B[2mURL\x1B[0m",J),console.debug("\x1B[2mPath Pattern\x1B[0m",V),console.debug("\x1B[2mStatus\x1B[0m",X.response?.status||200),console.debug("\x1B[2mMethod\x1B[0m",X.method||"GET"),console.debug("\n")}if(!Y)j.set(V,X);else return;if(!x)x=globalThis.fetch,globalThis.fetch=H;return!0},S=()=>{if(j.clear(),x)globalThis.fetch=x.bind({}),x=void 0},H=async(z,X)=>{const J=z instanceof Request?z.url:z.toString(),V=[...j.entries()].find(v([J,X]));if(!V)return Promise.reject(Q(404,J));if(process.env.VERBOSE)console.debug("\x1B[2mMocked fetch called\x1B[0m",J);const Y=V[1].response?.status||200;return Q(Y,J,V[1])};export{C as mock,S as clearMocks};

//# debugId=AB2F149D1D81550D64756E2164756E21
