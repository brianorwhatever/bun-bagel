{
  "version": 3,
  "sources": ["../src/constants.ts", "../src/utils.ts", "../src/mock.ts"],
  "sourcesContent": [
    "import { MockOptions } from \"./types\";\n\n/**\n * The default value for mock options.\n */\nexport const DEFAULT_MOCK_OPTIONS: MockOptions = {\n    method: 'GET',\n    data: null,\n    headers: new Headers(),\n    response: {\n        data: null,\n        headers: new Headers(),\n        status: 200,\n    }\n};",
    "import { DEFAULT_MOCK_OPTIONS } from \"./constants\";\nimport { MockOptions } from \"./types\";\n\n/**\n * @description Convert a wildcard string to a regular expression.\n * @param wildcardString - The wildcard string to convert. eg. '/api/*\\/users'\n * @returns A regular expression that matches the wildcard string.\n */\nexport function wildcardToRegex(wildcardString: string): RegExp {\n    // Escape special regex characters\n    const escapedString = wildcardString.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n\n    // Convert wildcard stars to regex patterns\n    const regexPattern = escapedString.replace(/\\\\\\*/g, \"[\\\\s\\\\S]*\");\n\n    // Anchor pattern for strict path matching\n    const anchoredPattern = `${regexPattern}$`;\n\n    return new RegExp(anchoredPattern);\n}\n\n/**\n * @description Find a requests.\n */\nexport const findRequest = (original: [string, RequestInit?]) => (mocked: [RegExp, MockOptions?]) => {\n    const [keyA, optionsA] = original;\n    const [keyB, optionsB] = mocked;\n\n    // Match keys.\n    const keysMatch = keyA.toString() === keyB.toString() || keyA.match(keyB);\n\n    if(!keysMatch)\n        return false;\n\n    // Match methods.\n    const methodA = optionsA?.method || \"GET\";\n    const methodB = optionsB?.method || \"GET\";\n\n    const methodMatch = methodA.toLowerCase() === methodB.toLowerCase();\n\n    if(!methodMatch)\n        return false;\n\n    // Match headers.\n    const headersA = new Headers(optionsA?.headers);\n    const headersB = new Headers(optionsB?.headers);\n\n    const headersMatch = [...headersB.entries()].every(([key, valueB]) => {\n        const valueA = headersA.get(key);\n        return valueA === valueB;\n    });\n\n    if(!headersMatch)\n        return false;\n\n    return true;\n}\n\n/**\n * Returns an object similar to Response class.\n * @param status - The HTTP status code of the response.\n * @param url - The URL of the request.\n * @param options - The options for the mocked request.\n * @returns An object similar to Response class.\n */\nexport const makeResponse = (status: number, url: string, options: MockOptions = DEFAULT_MOCK_OPTIONS) => {\n    const { headers, data, response } = options;\n\n    const ok = status >= 200 && status < 300;\n    const body = response?.data ?? data;\n\n    return {\n        ok,\n        status,\n        statusText: status,\n        url,\n        headers: response?.headers ?? headers,\n        text: () => Promise.resolve(body),\n        json: () => Promise.resolve(body),\n        redirected: false,\n        bodyUsed: !!body\n    };\n}",
    "import { DEFAULT_MOCK_OPTIONS } from \"./constants\";\nimport { MockOptions } from \"./types\";\nimport { findRequest, makeResponse, wildcardToRegex } from \"./utils\";\n\nlet ORIGINAL_FETCH: (request: Request, init?: RequestInit | undefined) => Promise<Response>;\n\n/**\n * The cache for registered mocked requests.\n */\nconst MOCKED_REQUESTS = new Map<RegExp, MockOptions>();\n\n/**\n * @description Mock the fetch method.\n */\nexport const mock = (request: Request | RegExp | string, options: MockOptions = DEFAULT_MOCK_OPTIONS) => {\n    const input = request instanceof Request ? request.url : request;\n\n    // Create regex class from input.\n    const regexInput = input instanceof RegExp ? input : new RegExp(wildcardToRegex(input.toString()));\n\n    // Check if request is already mocked.\n    const isRequestMocked = [...MOCKED_REQUESTS.entries()].find(findRequest([regexInput.toString(), options]));\n\n    if(process.env.VERBOSE) {\n        if (!isRequestMocked) \n            console.debug(\"\\x1b[1mRegistered mocked request\\x1b[0m\");\n        else\n            console.debug(\"\\x1b[1mRequest already mocked\\x1b[0m \\x1b[2mupdated\\x1b[0m\");\n\n        console.debug(\"\\x1b[2mURL\\x1b[0m\", input);\n        console.debug(\"\\x1b[2mPath Pattern\\x1b[0m\", regexInput);\n        console.debug(\"\\x1b[2mStatus\\x1b[0m\", options.response?.status || 200);\n        console.debug(\"\\x1b[2mMethod\\x1b[0m\", options.method || \"GET\");\n        console.debug(\"\\n\");\n    }\n\n    if(!isRequestMocked)\n        // Use regex as key.\n        MOCKED_REQUESTS.set(regexInput, options);\n    else\n        return;\n\n    if (!ORIGINAL_FETCH) {\n        // Cache the original fetch method before mocking it. Might be useful in the future to clean the mock.\n        ORIGINAL_FETCH = globalThis.fetch;\n\n        // @ts-ignore\n        globalThis.fetch = MOCKED_FETCH;\n    }\n    return true;\n}\n\n/**\n * @description Clear the fetch mock.\n */\nexport const clearMocks = () => {\n    MOCKED_REQUESTS.clear();\n\n    // Restore the original fetch method, if it was mocked.\n    if(!!ORIGINAL_FETCH) {\n        // @ts-ignore\n        globalThis.fetch = ORIGINAL_FETCH.bind({});\n        // @ts-ignore\n        ORIGINAL_FETCH = undefined;\n    }\n}\n\n/**\n * @description A mocked fetch method.\n */\nconst MOCKED_FETCH = async (_request: Request | RegExp | string, init?: RequestInit) => {\n    const _path = _request instanceof Request ? _request.url : _request.toString();\n\n    // When the request it fired, check if it matches a mocked request.\n    const mockedRequest = [...MOCKED_REQUESTS.entries()].find(findRequest([_path, init]));\n\n    if (!mockedRequest)\n        return Promise.reject(makeResponse(404, _path));\n\n    if(process.env.VERBOSE)\n        console.debug(\"\\x1b[2mMocked fetch called\\x1b[0m\", _path);\n\n    const mockedStatus = mockedRequest[1].response?.status || 200;\n\n    return makeResponse(mockedStatus, _path, mockedRequest[1]);\n};\n\n"
  ],
  "mappings": ";AAKO,IAAM,EAAoC,CAC7C,OAAQ,MACR,KAAM,KACN,QAAS,IAAI,QACb,SAAU,CACN,KAAM,KACN,QAAS,IAAI,QACb,OAAQ,GACZ,CACJ,ECNO,SAAS,CAAe,CAAC,EAAgC,CAQ5D,MAAM,EAAkB,GANF,EAAe,QAAQ,sBAAuB,MAAM,EAGvC,QAAQ,QAAS,WAAW,MAK/D,OAAO,IAAI,OAAO,CAAe,EAM9B,IAAM,EAAc,CAAC,IAAqC,CAAC,IAAmC,CACjG,MAAO,EAAM,GAAY,GAClB,EAAM,GAAY,EAKzB,KAFkB,EAAK,SAAS,IAAM,EAAK,SAAS,GAAK,EAAK,MAAM,CAAI,GAGpE,MAAO,GAGX,MAAM,EAAU,GAAU,QAAU,MAC9B,EAAU,GAAU,QAAU,MAIpC,GAFoB,EAAQ,YAAY,IAAM,EAAQ,YAAY,EAG9D,MAAO,GAGX,MAAM,EAAW,IAAI,QAAQ,GAAU,OAAO,EAQ9C,IALqB,CAAC,GAFL,IAAI,QAAQ,GAAU,OAAO,EAEZ,QAAQ,CAAC,EAAE,MAAM,EAAE,EAAK,KAAY,CAElE,OADe,EAAS,IAAI,CAAG,IACb,EACrB,EAGG,MAAO,GAEX,MAAO,IAUE,EAAe,CAAC,EAAgB,EAAa,EAAuB,IAAyB,CACtG,MAAQ,UAAS,OAAM,YAAa,EAE9B,EAAK,GAAU,KAAO,EAAS,IAC/B,EAAO,GAAU,MAAQ,EAE/B,MAAO,CACH,KACA,SACA,WAAY,EACZ,MACA,QAAS,GAAU,SAAW,EAC9B,KAAM,IAAM,QAAQ,QAAQ,CAAI,EAChC,KAAM,IAAM,QAAQ,QAAQ,CAAI,EAChC,WAAY,GACZ,WAAY,CAChB,GC7EJ,IAAI,EAKE,EAAkB,IAAI,IAKf,EAAO,CAAC,EAAoC,EAAuB,IAAyB,CACrG,MAAM,EAAQ,aAAmB,QAAU,EAAQ,IAAM,EAGnD,EAAa,aAAiB,OAAS,EAAQ,IAAI,OAAO,EAAgB,EAAM,SAAS,CAAC,CAAC,EAG3F,EAAkB,CAAC,GAAG,EAAgB,QAAQ,CAAC,EAAE,KAAK,EAAY,CAAC,EAAW,SAAS,EAAG,CAAO,CAAC,CAAC,EAEzG,GAAG,QAAQ,IAAI,QAAS,CACpB,IAAK,EACD,QAAQ,MAAM,yCAAyC,MAEvD,SAAQ,MAAM,4DAA4D,EAE9E,QAAQ,MAAM,oBAAqB,CAAK,EACxC,QAAQ,MAAM,6BAA8B,CAAU,EACtD,QAAQ,MAAM,uBAAwB,EAAQ,UAAU,QAAU,GAAG,EACrE,QAAQ,MAAM,uBAAwB,EAAQ,QAAU,KAAK,EAC7D,QAAQ,MAAM,IAAI,EAGtB,IAAI,EAEA,EAAgB,IAAI,EAAY,CAAO,MAEvC,QAEJ,IAAK,EAED,EAAiB,WAAW,MAG5B,WAAW,MAAQ,EAEvB,MAAO,IAME,EAAa,IAAM,CAI5B,GAHA,EAAgB,MAAM,EAGjB,EAED,WAAW,MAAQ,EAAe,KAAK,CAAC,CAAC,EAEzC,EAAiB,QAOnB,EAAe,MAAO,EAAqC,IAAuB,CACpF,MAAM,EAAQ,aAAoB,QAAU,EAAS,IAAM,EAAS,SAAS,EAGvE,EAAgB,CAAC,GAAG,EAAgB,QAAQ,CAAC,EAAE,KAAK,EAAY,CAAC,EAAO,CAAI,CAAC,CAAC,EAEpF,IAAK,EACD,OAAO,QAAQ,OAAO,EAAa,IAAK,CAAK,CAAC,EAElD,GAAG,QAAQ,IAAI,QACX,QAAQ,MAAM,oCAAqC,CAAK,EAE5D,MAAM,EAAe,EAAc,GAAG,UAAU,QAAU,IAE1D,OAAO,EAAa,EAAc,EAAO,EAAc,EAAE",
  "debugId": "AB2F149D1D81550D64756E2164756E21",
  "names": []
}